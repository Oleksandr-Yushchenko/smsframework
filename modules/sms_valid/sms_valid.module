<?php

/**
 * @file
 * Number validation feature module for Drupal SMS Framework.
 *
 * @package sms
 * @subpackage sms_valid
 */


/**
 * Implements hook_sms_validate().
 *
 * @param $op
 *   Validation operation to work on.
 * @param $number
 *   Phone number string.
 * @param $options
 *   Array of options.
 *
 * @return
 *   NULL if validation succeeded. Error string if failed.
 *
 * @ingroup hooks
 */
function sms_valid_sms_validate($op, &$number, &$options) {
  if ($op == 'process') {
    if (\Drupal::config('sms_valid')->get('use_rulesets') || array_key_exists('test', $options)) {
      $result = sms_valid_validate($number, $options);

      if ($result['pass']) {
        return NULL;
      }
      else {
        return array_pop($result['log']);
      }
    }
  }
}

/**
 * Implements hook_theme().
 *
 * @return
 *   Array of Drupal theme items.
 *
 * @ingroup hooks
 */
function sms_valid_theme() {
  return array(
    'sms_valid_admin_rulesets_form' => array(
      'render element' => 'form',
    ),
    'sms_valid_admin_ruleset_form' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Access callback for sms_ruleset Entity type
 */
function sms_ruleset_access() {
  return user_access('administer smsframework');
}



/**
 * Get all rulesets
 *
 * @return
 *   Array of rulesets.
 */
function sms_valid_get_all_rulesets() {
  $rulesets = entity_load_multiple('sms_ruleset');
  return $rulesets;
}

/**
 * Get a ruleset for a given prefix
 *
 * @param $prefix
 *   A numberic prefix.
 *
 * @return \Drupal\sms_valid\Entity\Ruleset
 *   A ruleset entity.
 */
function sms_valid_get_ruleset($prefix) {
  return entity_load('sms_ruleset', $prefix);
}


/**
 * Get the best ruleset for a given phone number
 *
 * @param $number
 *   A phone number.
 *
 * @return
 *   A ruleset array or NULL.
 */
function sms_valid_get_ruleset_for_number($number) {
  // Strip all non-digit chars including whitespace
  $number = preg_replace('/[^0-9]/', '', $number);

  // Make an array of potential prefixes from the given number
  for ($i = 0; $i < drupal_strlen($number); $i++) {
    $potential_prefixes[] = drupal_substr($number, 0, $i + 1);
  }

  $best_ruleset = NULL;
  $last_prefix  = NULL;
  $ids = \Drupal::entityQuery('sms_ruleset')
    ->condition('prefix', $potential_prefixes, 'IN')
    ->execute();
  $rulesets = entity_load_multiple('sms_ruleset', $ids);
  foreach ($rulesets as $ruleset) {
    if ($ruleset->prefix > $last_prefix) {
      $best_ruleset = $ruleset;
      $last_prefix = $ruleset->prefix;
    }
  }

  return $best_ruleset;
}


/**
 * Get prefixes for a given ISO country code
 *
 * @param $iso2
 *   A two-character ISO-3166-1 alpha-2 country code
 *
 * @return
 *   Array of prefix numbers.
 */
function sms_valid_get_prefixes_for_iso2($iso2) {
  return Drupal::entityQuery('sms_ruleset')
    ->condition('iso2', $iso2)
    ->execute();
}


/**
 * Check what directions are enabled for a ruleset
 *
 * @param $prefix
 *   A prefix number.
 * @param $dir
 *   The direction code that you want to check. See SMS_DIR_* constants.
 *
 * @return
 *   Boolean. Whether the ruleset is enabled for this direction.
 */
function sms_valid_ruleset_is_enabled($prefix, $dir = SMS_DIR_OUT) {
  $ruleset = entity_load('sms_ruleset', $prefix);

  if ($ruleset) {
    // There must be a better way of doing this, but this works ok
    if ($ruleset->dirs_enabled == SMS_DIR_ALL) {
      return TRUE;
    }
    if ($ruleset->dirs_enabled == SMS_DIR_OUT && $dir == SMS_DIR_OUT) {
      return TRUE;
    }
    if ($ruleset->dirs_enabled == SMS_DIR_IN    && $dir == SMS_DIR_IN) {
      return TRUE;
    }
  }
  return FALSE;
}


/**
 * Set enabled directions for a ruleset
 *
 * @param $prefix
 *   A prefix number.
 * @param $dir
 *   The direction code that you want to set. See SMS_DIR_* constants.
 *
 * @return
 *   Bollean. Result of the DB query.
 */
function sms_valid_ruleset_set_status($prefix, $dir = SMS_DIR_ALL) {
  $ruleset = entity_load('sms_ruleset', $prefix);
  $ruleset->dirs_enabled = $dir;
  return $ruleset->save();
}


/**
 * Create or update a ruleset
 *
 * @param $ruleset
 *   A ruleset array.
 *
 * @return
 *   Boolean. Result of the DB query.
 */
function sms_valid_save_ruleset($ruleset) {
  $ruleset->save();
}


/**
 * Delete a ruleset
 *
 * @param $prefix
 *   A prefix number.
 *
 * @return
 *   Boolean. Result of the DB query.
 */
function sms_valid_delete_ruleset($prefix) {
  return entity_load('sms_ruleset', $prefix)->delete();
}


/**
 * Get the rules for a prefix
 *
 * @param $rules
 *   A prefix number.
 *
 * @return
 *   An array of rules.
 */
function sms_valid_get_rules($prefix) {
  $ruleset = sms_valid_get_ruleset($prefix);
  return $ruleset->rules;
}


/**
 * Distill rules text into a rules array
 *
 * @param $text
 *   A text string containing rules for a ruleset.
 *
 * @return
 *   An array of rules.
 */
function sms_valid_text_to_rules($text) {
  $lines = explode("\n", trim($text));
  $rules = array();

  foreach ($lines as $line) {
    if (empty($line)) {
      continue;
    }

    // Capture any comments and then strip them
    preg_match('/\#(.*)/', $line, $matches);
    if (isset($matches[1])) {
      $comment = trim($matches[1]);
    }
    else {
      $comment = '';
    }
    $line = trim(preg_replace('/\#.*/', '', $line));

    // Check if we are allowing or denying, deny by default
    $allow = preg_match('/\+/', $line) ? TRUE : FALSE;

    // Erase non-digit chars to get the prefix
    $rule_prefix = trim(preg_replace('/[\D]/', '', $line));

    // Add to rules array
    $rules[$rule_prefix] = array(
      'allow' => $allow,
      'comment' => $comment,
    );
  }
  return $rules;
}


/**
 * Implode a rules array into rules text
 *
 * @param $rules
 *   A rules array.
 *
 * @return
 *   A text string containing rules for a ruleset.
 */
function sms_valid_rules_to_text($rules) {
  $lines   = array();

  if ($rules && is_array($rules)) {
    foreach ($rules as $rule_prefix => $rule) {
      $allow       = ($rule['allow']) ? '+' : '-';
      $comment     = ($rule['comment']) ? '    # ' . $rule['comment'] : '';
      $lines[]     = $rule_prefix . $allow . $comment;
    }
  }

  return implode("\n", $lines);
}


/**
 * Get country codes for form options
 *
 * @param $include_null_option
 *   Whether to include a null option in the resulting array. TRUE or FALSE.
 *
 * @return
 *   Options array that can be used in a form select element.
 */
function sms_valid_get_rulesets_for_form($include_null_option = FALSE) {
  $options = array();
  // We only really need a null option on the send form
  if ($include_null_option) {
    $options[-1] = '(auto select)';
  }

  // Other options
  $rulesets = sms_valid_get_all_rulesets();
  foreach ($rulesets as $prefix => $ruleset) {
    $suffix = (!empty($ruleset->iso2)) ? ' (' . $ruleset->iso2 . ')' : '';
    $options[$prefix] = $prefix . ' : ' . $ruleset->name . $suffix;
  }
  return $options;
}


/**
 * Check if number is a local number
 *
 * @param $number
 *   A phone number
 *
 * @return
 *   Boolean. Whether this is a local number.
 */
function sms_valid_is_local_number($number) {
  $prefix = \Drupal::config('sms_valid.settings')->get('local_number_prefix');
  // A blank prefix string makes this return false
  if ($prefix !== '' && preg_match("/^$prefix/", $number)) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}


/**
 * Validate a number
 *
 * @param $number
 *   A phone number.
 * @param $options
 *   An array of options.
 *   - dir  : Direction of message. See SMS_DIR_* constants.
 *
 * @return
 *   Array with the validation result.
 *   - pass : The validation result.
 *       - TRUE  if the number passed validation checks.
 *       - FALSE if the number is denied by validation.
 *       - NULL  if the number could not be validated.
 *   - log  : Array of log strings. The last record is the most significant.
 */
function sms_valid_validate(&$number, &$options = array()) {
  $result = array(
    'pass' => NULL,
    'log' => array(),
  );

  // Set the default direction if not specified in options
  $dir = (array_key_exists('dir', $options)) ? $options['dir'] : SMS_DIR_OUT;

  $config = \Drupal::config('sms_valid.settings');
  $use_global_ruleset   = $config->get('use_global_ruleset');
  $global_ruleset       = $config->get('global_ruleset');
  $local_number_prefix  = $config->get('local_number_prefix');
  $local_number_ruleset = $config->get('local_number_ruleset');
  $last_resort_enabled  = $config->get('last_resort_enabled');
  $last_resort_ruleset  = $config->get('last_resort_ruleset');

  // Check if we should use a specific ruleset prefix
  if (array_key_exists('prefix', $options) && $options['prefix'] >= 0) {
    $specific_prefix = $options['prefix'];
  }
  else {
    $specific_prefix = NULL;
  }

  // Check for zero-length value
  if (!strlen($number)) {
    $result['log'][] = t('You must enter a phone number.');
    return $result;
  }

  // Remove all whitespace
  $number = preg_replace('/[^\d]/', '', $number);

  // Check if we should use a specific ruleset
  if ($specific_prefix) {
    $prefix  = $specific_prefix;
    $ruleset = sms_valid_get_ruleset($prefix);
    // Strip ruleset prefix (if exist) and leading zeros from the number
    $num     = preg_replace("/^$prefix/", '', $number);
    $num     = ltrim($num, '0');
  }
  // Check if we should use the global ruleset
  elseif ($use_global_ruleset) {
    $result['log'][] = t('Using the global prefix validation ruleset.');
    $prefix  = $global_ruleset;
    $ruleset = sms_valid_get_ruleset($prefix);
    $num     = $number;
  }
  // Check if this is a local number
  elseif (sms_valid_is_local_number($number)) {
    $prefix  = $local_number_ruleset;
    $ruleset = sms_valid_get_ruleset($prefix);
    $result['log'][] = t('Identified local number. Using ruleset prefix @prefix', array('@prefix' => $prefix));
    // Strip the local prefix from number
    $num     = preg_replace("/^$local_number_prefix/", '', $number);
  }
  // Perform ruleset discovery
  else {
    $ruleset  = sms_valid_get_ruleset_for_number($number);

    if ($ruleset) {
      $prefix = $ruleset->prefix;
      $result['log'][] = t('Identified ruleset prefix @prefix', array('@prefix' => $prefix));
    }
    else {
      // Could not identify ruleset prefix
      $result['log'][] = t('Could NOT identify the ruleset prefix for number @number', array('@number' => $number));

      if ($last_resort_enabled && $last_resort_ruleset) {
        // We have a last resort to use
        $result['log'][] = t('Using last resort ruleset prefix @last_resort', array('@last_resort' => $last_resort_ruleset));
        $prefix  = $last_resort_ruleset;
        $ruleset = sms_valid_get_ruleset($prefix);
      }
      else {
        // No last resort. Fail hard.
        $result['log'][] = t('No matching rulesets and no last resort ruleset configured.');
        $result['log'][] = t('Cannot validate this number. Denied by default.');
        return $result;
      }
    }
    // Strip the ruleset prefix from the number
    $num = preg_replace("/^$prefix/", '', $number);
  }

  // Get the rules for this ruleset
  $rules = $ruleset->rules;

  // Lets make sure we have a rule before trying to sort it
  if ($rules !== NULL) {
    // Sort the rules by prefix (key) in reverse order (largest to smallest)
    krsort($rules);
  }

  // Check whether this ruleset is enabled for the direction of communication
  if (!sms_valid_ruleset_is_enabled($prefix, $dir)) {
    $result['log'][] = t('Number prefix @prefix does not allow messages in this direction.', array('@prefix' => $prefix));
    $result['pass']  = FALSE;
    return $result;
  }

  // Test the number against each rule prefix until we get a match
  if (!empty($rules)) {
    foreach ($rules as $rule_prefix => $rule) {
      $args = array('@prefix' => $prefix, '@rule_prefix' => $rule_prefix, '@number' => $num);
      $result['log'][] = t('Trying rule with prefix @rule_prefix on number @number', $args);
      if (preg_match("/^$rule_prefix/", $num)) {
        if ($rule['allow']) {
          // Set the full validated number and return
          $number = $prefix . $num;
          $result['log'][] = t('Explicit allow for prefix @prefix @rule_prefix', $args);
          $result['pass']  = TRUE;
          return $result;
        }
        else {
          $result['log'][] = t('Explicit deny for prefix @prefix @rule_prefix', $args);
          $result['pass']  = FALSE;
          return $result;
        }
      }
    }
  }

  // No matching rules. Default deny.
  $result['log'][] = t('Cannot validate this number. Denied by default.');
  return $result;
}

/**
 * @see sms_valid_admin_ruleset_form()
 */
function theme_sms_valid_admin_ruleset_form($variables) {
  $form = $variables['form'];
  $header = array();
  $rows   = array();
  $rows[] = array(
    array(
      'data' => '<strong>' . drupal_render($form['title']) . '</strong>',
      'colspan' => 3,
    ),
  );

  $rows[] = array(
    drupal_render($form['select_prefix']),
    drupal_render($form['select']),
    array(
      'data' => '',
      'width' => '80%',
    ),
  );
  unset($form['title']);
  unset($form['select_prefix']);
  unset($form['select']);

  $output = _theme(
    'table', array(
      'header' => $header,
      'rows' => $rows,
    )
  );

  $output .= drupal_render_children($form);

  return $output;
}

/**
 * @see sms_valid_admin_rulesets_form()
 */
function theme_sms_valid_admin_rulesets_form($variables)
{
  $form = $variables['form'];
  $output = '';
  $rows = array();
  foreach ($form as $prefix => $element) {
    if (is_array($element) && isset($element['prefix']) && is_array($element['prefix'])) {
      $rows[] = array(
        drupal_render($element['prefix']),
        drupal_render($element['name']),
        drupal_render($element['iso2']),
        drupal_render($element['qty_rules']),
        drupal_render($element[$prefix . '_out']),
        drupal_render($element[$prefix . '_in']),
        drupal_render($element[$prefix . '_delete']),
      );
      unset($form[$prefix]);
    }
  }
  $output .= drupal_render_children($form['note']);
  unset($form['note']);

  $header = array(
    t('Prefix'),
    t('Name'),
    t('Country'),
    t('Qty Rules'),
    array(
      'data' => t('Allow messages'),
      'colspan' => 2,
    ),
    t('Delete'));

  $output .= _theme('table', array(
    'header' => $header,
    'rows' => $rows,
  ));
  $output .= drupal_render_children($form);

  return $output;
}

